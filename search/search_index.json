{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Python Programming","text":"<p>Welcome to the Introduction to Python Programming This training introduces Python programming and its application in geospatial data processing and geospatial artificial intelligence (GeoAI).</p>"},{"location":"#objectives","title":"Objectives","text":"<p>By the end of this training, you will be able to:</p> <ul> <li>Understand Python basics and data structures  </li> <li>Work with shapefiles and raster data  </li> <li>Clip, mask, and extract raster patches  </li> <li>Apply machine learning and deep learning </li> <li>Use Google Earth Engine (GEE) for large-scale geospatial analysis</li> </ul>"},{"location":"#training-structure","title":"Training Structure","text":"<p>The training is organized into four main sections:</p> <ol> <li> <p>Python Environments    Create and manage environments using tools like Miniforge and <code>venv</code>.</p> </li> <li> <p>Python Basics    Learn variables, loops, functions, and file handling.</p> </li> <li> <p>Working with Geospatial Data    Learn about vectors, rasters, CRS, and raster processing with Python and the GEE Python API.</p> </li> <li> <p>Geospatial AI    Train machine learning and deep learning models to classify crop types.</p> </li> </ol>"},{"location":"#requirements-to-run-python","title":"Requirements to Run Python","text":"<p>To successfully follow along, you\u2019ll need:</p>"},{"location":"#1-python-installation","title":"1. Python Installation","text":"<ul> <li>Recommended: Miniforge</li> <li>Lightweight Conda-based Python distribution</li> <li>Alternative:</li> <li>Python.org</li> <li>Anaconda</li> </ul>"},{"location":"#2-code-editors","title":"2. Code Editors","text":"<p>You can write and run Python code using:</p> <ul> <li>Visual Studio Code (VS Code)</li> <li>JupyterLab</li> <li>PyCharm</li> <li>Online alternative: Google Colab (no installation needed)</li> </ul> <p>Google Colab is especially helpful when using GPUs or accessing cloud resources.</p>"},{"location":"#lets-get-started","title":"Let's Get Started","text":"<p>Head to the next section: Python Environment Management</p>"},{"location":"Coordinate_Reference_Systems/","title":"Coordinate Reference Systems (CRS)","text":"<p>A Coordinate Reference System (CRS) defines how the two-dimensional, projected map in your GIS relates to real places on the earth.</p> <p>CRS is crucial for aligning and analyzing geospatial data accurately.</p>"},{"location":"Coordinate_Reference_Systems/#types-of-crs","title":"Types of CRS","text":"<p>There are two main types of CRS:</p> Type Description Example Geographic CRS Uses latitude and longitude (angular units) EPSG:4326 (WGS 84) Projected CRS Uses meters or feet on a flat surface EPSG:32636 (UTM)"},{"location":"Coordinate_Reference_Systems/#checking-and-setting-crs","title":"Checking and Setting CRS","text":"<pre><code>import geopandas as gpd\n\n# Load shapefile\ngdf = gpd.read_file(\"farms.shp\")\n\n# Check CRS\nprint(gdf.crs)\n\n# Reproject to UTM Zone 36N\ngdf_utm = gdf.to_crs(\"EPSG:32636\")\nprint(gdf_utm.crs)\n</code></pre> <p>You can reproject raster files too:</p> <pre><code>import rasterio\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\n\nwith rasterio.open(\"satellite.tif\") as src:\n    dst_crs = \"EPSG:4326\"\n    transform, width, height = calculate_default_transform(\n        src.crs, dst_crs, src.width, src.height, *src.bounds\n    )\n\n    kwargs = src.meta.copy()\n    kwargs.update({\n        'crs': dst_crs,\n        'transform': transform,\n        'width': width,\n        'height': height\n    })\n\n    with rasterio.open(\"reprojected.tif\", 'w', **kwargs) as dst:\n        for i in range(1, src.count + 1):\n            reproject(\n                source=rasterio.band(src, i),\n                destination=rasterio.band(dst, i),\n                src_transform=src.transform,\n                src_crs=src.crs,\n                dst_transform=transform,\n                dst_crs=dst_crs,\n                resampling=Resampling.nearest\n            )\n</code></pre>"},{"location":"Coordinate_Reference_Systems/#why-crs-matters","title":"Why CRS Matters","text":"<ul> <li>Ensures datasets align correctly on the map</li> <li>Allows spatial measurements (distance, area)</li> <li>Required for overlays, joins, or clipping operations</li> </ul>"},{"location":"Coordinate_Reference_Systems/#common-epsg-codes","title":"Common EPSG Codes","text":"EPSG Code Name Description 4326 WGS84 Global Lat/Lon (GPS) 3857 Web Mercator Used in web maps (Google, OSM) 32636 UTM Zone 36N (WGS84) East Africa (meters) 21097 Arc 1960 / UTM zone 37S Kenya"},{"location":"Coordinate_Reference_Systems/#exercises","title":"Exercises","text":"<ol> <li>Load a vector file and print its CRS.</li> <li>Reproject a shapefile from WGS84 to UTM.</li> <li>Load a raster and display its CRS.</li> <li>Reproject a raster using Rasterio and save the output.</li> <li>Bonus: Search the EPSG registry and find the correct code for your country\u2019s UTM zone.</li> </ol> <p>\u2b05\ufe0f Previous: Understanding Vector vs Raster Data | Next: Reading and Plotting Shapefiles \u27a1\ufe0f</p>"},{"location":"Crop_Classification_ML_DL/","title":"Crop Classification with Machine Learning and Deep Learning","text":"<p>This section introduces both Machine Learning (Random Forest) and Deep Learning (Convolutional Neural Networks - CNN) for geospatial applications.</p>"},{"location":"Crop_Classification_ML_DL/#use-case-classifying-crop-types","title":"Use Case: Classifying Crop Types","text":"<p>Geospatial AI enables us to classify agricultural land based on satellite imagery. In this example, we use machine learning and deep learning models to classify crop types from raster patches derived from Sentinel-2 imagery or other multispectral sources.</p>"},{"location":"Crop_Classification_ML_DL/#workflow-overview","title":"Workflow Overview","text":"<ol> <li>Clip and mask raster imagery using crop boundaries (shapefiles)</li> <li>Extract image patches (e.g., 64\u00d764) labeled by crop type</li> <li>Prepare features or patch arrays</li> <li>Train Random Forest or CNN models</li> <li>Predict crop types for new imagery</li> </ol>"},{"location":"Crop_Classification_ML_DL/#machine-learning-with-random-forest","title":"Machine Learning with Random Forest","text":"<p>Random Forest is an ensemble learning method effective for structured features like NDVI, texture stats, or spectral means per patch.</p>"},{"location":"Crop_Classification_ML_DL/#random-forest-example","title":"Random Forest Example","text":"<pre><code>from sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\nimport numpy as np\n\n# Load tabular features and crop labels\nX = np.load(\"features.npy\")  # (n_samples, n_features)\ny = np.load(\"labels.npy\")    # (n_samples,)\n\n# Split data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\n\n# Train model\nmodel = RandomForestClassifier()\nmodel.fit(X_train, y_train)\n\n# Predict and evaluate\ny_pred = model.predict(X_test)\nprint(\"Accuracy:\", accuracy_score(y_test, y_pred))\n</code></pre>"},{"location":"Crop_Classification_ML_DL/#deep-learning-with-cnn-using-keras","title":"Deep Learning with CNN (using Keras)","text":"<p>CNNs are ideal for classifying raw raster patches without manual feature extraction.</p>"},{"location":"Crop_Classification_ML_DL/#cnn-example","title":"CNN Example","text":"<pre><code>import tensorflow as tf\nfrom tensorflow.keras import layers, models\n\n# Load image patches (e.g., 64\u00d764\u00d7bands)\nX = np.load(\"patches.npy\")\ny = np.load(\"labels.npy\")\n\n# Split data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\n\n# Define CNN model\nmodel = models.Sequential([\n    layers.Conv2D(32, (3, 3), activation='relu', input_shape=X.shape[1:]),\n    layers.MaxPooling2D((2, 2)),\n    layers.Conv2D(64, (3, 3), activation='relu'),\n    layers.Flatten(),\n    layers.Dense(64, activation='relu'),\n    layers.Dense(len(np.unique(y)), activation='softmax')\n])\n\nmodel.compile(optimizer='adam',\n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\n\n# Train model\nmodel.fit(X_train, y_train, epochs=10, batch_size=32, validation_split=0.2)\n</code></pre>"},{"location":"Crop_Classification_ML_DL/#model-evaluation","title":"Model Evaluation","text":"<pre><code># Evaluate CNN accuracy\nloss, accuracy = model.evaluate(X_test, y_test)\nprint(\"CNN Accuracy:\", accuracy)\n</code></pre>"},{"location":"Crop_Classification_ML_DL/#tips","title":"Tips","text":"<ul> <li>Normalize patch values (0\u20131) before training CNNs.</li> <li>Use class weights if crop types are imbalanced.</li> <li>Use <code>model.save()</code> to reuse trained models later.</li> </ul>"},{"location":"Crop_Classification_ML_DL/#exercises","title":"Exercises","text":"<ol> <li>Train a Random Forest model using tabular crop feature data.</li> <li>Extract and save raster patches labeled by crop type.</li> <li>Train a CNN on patch data and compare results to RF.</li> <li>Visualize model predictions as classification maps.</li> <li>Save trained models and test them on new images.</li> </ol> <p>\u2b05\ufe0f Previous: Google Earth Engine Python API</p>"},{"location":"Functions_and_File_IO/","title":"Functions and File I/O","text":"<p>Functions and file input/output (I/O) are essential tools in Python that allow you to:</p> <ul> <li>Reuse blocks of code</li> <li>Organize logic into manageable units</li> <li>Read and write files for automation and reporting</li> </ul>"},{"location":"Functions_and_File_IO/#defining-and-using-functions","title":"Defining and Using Functions","text":"<p>Functions are declared using the <code>def</code> keyword. They can accept parameters and return results.</p> <pre><code># Define a function to calculate yield\ndef calculate_yield(area, rate):\n    return area * rate\n\n# Use the function\nresult = calculate_yield(10, 2.5)\nprint(\"Total Yield:\", result)\n</code></pre> <p>Tips:</p> <ul> <li>Functions improve modularity and reusability.</li> <li>You can return multiple values using tuples.</li> </ul>"},{"location":"Functions_and_File_IO/#built-in-python-functions","title":"Built-in Python Functions","text":"<p>Python provides a rich set of built-in functions:</p> <pre><code>crops = ['Maize', 'Beans']\n\nprint(len(crops))       # Count items\nprint(type(crops))      # Type of variable\nprint(sorted(crops))    # Sorted list\n</code></pre>"},{"location":"Functions_and_File_IO/#reading-from-files","title":"Reading from Files","text":"<p>Use the built-in <code>open()</code> function to read content from files (e.g., text or CSV).</p> <pre><code># Reading a file line by line\nwith open('crop_names.txt', 'r') as file:\n    for line in file:\n        print(\"Crop:\", line.strip())\n</code></pre> <p>Common modes:</p> <ul> <li><code>'r'</code>: read</li> <li><code>'w'</code>: write (overwrites)</li> <li><code>'a'</code>: append</li> <li><code>'rb'</code>: read binary</li> </ul>"},{"location":"Functions_and_File_IO/#writing-to-files","title":"Writing to Files","text":"<p>To save data or reports to a file:</p> <pre><code># Writing to a file\nwith open('output.txt', 'w') as file:\n    file.write(\"Crop Yield Report\\n\")\n    file.write(\"Maize: 2.5 tons/ha\\n\")\n</code></pre> <p>Always use <code>with open(...)</code> \u2014 it automatically closes the file safely.</p>"},{"location":"Functions_and_File_IO/#exercises","title":"Exercises","text":"<ol> <li>Write a function that calculates the cost of production given area and cost per hectare.</li> <li>Create a function that returns the longer of two crop names.</li> <li>Read a file with crop names and print each with <code>\"Crop:\"</code> prefix.</li> <li>Write a function that takes a list of yields and writes them to a file.</li> <li>Extend the above function to also return the average yield.</li> </ol> <p>\u2b05\ufe0f Previous: Loops and Conditionals | Next: Vector vs Raster Data \u27a1\ufe0f</p>"},{"location":"GEE_Python_API/","title":"Google Earth Engine Python API","text":"<p>Google Earth Engine (GEE) is a cloud-based platform for planetary-scale geospatial analysis. Its Python API allows users to access GEE datasets and run computations using Python scripts.</p>"},{"location":"GEE_Python_API/#setup-and-authentication","title":"Setup and Authentication","text":"<p>Install Earth Engine Python API:</p> <pre><code>pip install earthengine-api\n</code></pre> <p>Authenticate and initialize:</p> <pre><code>import ee\nee.Authenticate()\nee.Initialize()\n</code></pre>"},{"location":"GEE_Python_API/#load-and-filter-a-dataset","title":"Load and Filter a Dataset","text":"<p>Example: Load Sentinel-2 imagery for a region and time range.</p> <pre><code>point = ee.Geometry.Point([30.05, -1.95])  # Example location\n\ncollection = (\n    ee.ImageCollection('COPERNICUS/S2_SR')\n    .filterBounds(point)\n    .filterDate('2021-01-01', '2021-03-31')\n    .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n)\n\nimage = collection.median()\n</code></pre>"},{"location":"GEE_Python_API/#export-image-to-google-drive","title":"Export Image to Google Drive","text":"<pre><code>task = ee.batch.Export.image.toDrive(\n    image=image,\n    description='S2_Nyagatare_2021Q1',\n    folder='GEE_exports',\n    fileNamePrefix='sentinel2_2021',\n    region=point.buffer(10000).bounds().getInfo()['coordinates'],\n    scale=10,\n    crs='EPSG:4326'\n)\ntask.start()\n</code></pre>"},{"location":"GEE_Python_API/#visualize-with-folium","title":"Visualize with Folium","text":"<pre><code>import folium\nfrom geemap import foliumap\n\nMap = folium.Map(location=[-1.95, 30.05], zoom_start=10)\nMap.add_child(folium.TileLayer('Stamen Terrain'))\n\nvis_params = {'min': 0, 'max': 3000, 'bands': ['B4', 'B3', 'B2']}\nMap.add_ee_layer(image, vis_params, 'Sentinel-2')\nMap\n</code></pre> <p>Note: You need <code>geemap</code> for <code>add_ee_layer</code>.</p> <pre><code>pip install geemap\n</code></pre>"},{"location":"GEE_Python_API/#tips","title":"Tips","text":"<ul> <li>Use <code>.first()</code> to inspect the first image in a collection.</li> <li>Combine with <code>geopandas</code> for geospatial integration.</li> <li>Use the Code Editor (code.earthengine.google.com) to validate expressions.</li> </ul>"},{"location":"GEE_Python_API/#exercises","title":"Exercises","text":"<ol> <li>Load Landsat-8 images for a region of interest and filter by date/clouds.</li> <li>Export an NDVI image to Google Drive.</li> <li>Visualize an image using Folium and geemap.</li> <li>Use <code>.mean()</code> instead of <code>.median()</code> and compare results.</li> </ol>"},{"location":"GEE_Python_API/#resources","title":"Resources","text":"<ul> <li>GEE Python API Docs</li> <li>Geemap Docs</li> </ul> <p>\u2b05\ufe0f Previous: Patch Extraction from Rasters | Next: Geospatial AI Summary \u27a1\ufe0f</p>"},{"location":"Lists_Dictionaries_Tuples/","title":"Lists, Dictionaries, and Tuples","text":"<p>Python provides several built-in data structures to store collections of items. For crop mapping and geospatial tasks, the most commonly used ones are:</p> <ul> <li><code>list</code>: ordered, changeable collection</li> <li><code>tuple</code>: ordered, unchangeable collection</li> <li><code>dict</code>: key-value mappings</li> </ul>"},{"location":"Lists_Dictionaries_Tuples/#lists","title":"Lists","text":"<p>Lists are ordered and mutable collections that can store any type of data.</p> <pre><code># Define a list of crops\ncrops = ['Maize', 'Beans', 'Sorghum']\n\n# Access items\nprint(crops[0])  # Output: Maize\n\n# Add new item\ncrops.append('Cassava')\n\n# Check contents\nprint(crops)\n</code></pre> <p>Common List Methods</p> <ul> <li><code>append()</code>: Add item to end</li> <li><code>remove()</code>: Remove by value</li> <li><code>sort()</code>: Sort items</li> <li><code>len()</code>: Get number of items</li> </ul>"},{"location":"Lists_Dictionaries_Tuples/#tuples","title":"Tuples","text":"<p>Tuples are like lists, but immutable (they cannot be changed after creation). Use them to store fixed data like coordinates.</p> <pre><code># Define a tuple\ncoordinates = (1.95, 30.06)\n\n# Access values\nprint(\"Latitude:\", coordinates[0])\n</code></pre>"},{"location":"Lists_Dictionaries_Tuples/#dictionaries","title":"Dictionaries","text":"<p>Dictionaries store data in key-value pairs. They\u2019re ideal for mapping relationships, such as crop name \u2192 yield.</p> <pre><code># Create a dictionary of crop yields\ncrop_yields = {\n    'Maize': 2.5,\n    'Beans': 1.8\n}\n\n# Access value by key\nprint(crop_yields['Maize'])  # Output: 2.5\n\n# Add new entry\ncrop_yields['Sorghum'] = 2.0\n\n# Display all keys\nprint(crop_yields.keys())\n\n# Get value safely using .get()\nprint(crop_yields.get('Millet'))  # Output: None\n\n# Display all values\nprint(crop_yields.values())\n\n# Display key-value pairs\nprint(crop_yields.items())\n\n</code></pre> <p>Common Dictionary Methods</p> <ul> <li><code>get(key)</code>: Get value safely</li> <li><code>keys()</code>: Return all keys</li> <li><code>values()</code>: Return all values</li> <li><code>items()</code>: Return key-value pairs</li> </ul>"},{"location":"Lists_Dictionaries_Tuples/#exercises","title":"Exercises","text":"<ol> <li>Create a list of five crops and print the third crop.</li> <li>Create a tuple representing the lat/lon of a farm location.</li> <li>Create a dictionary with crop names as keys and yield per hectare as values.</li> <li>Add a new crop to the dictionary and print all items.</li> <li>Write a function that takes a crop name and returns the yield from the dictionary.</li> </ol> <p>\u2b05\ufe0f Previous: Variables and Data Types | Next: Numpy, Pandas \u27a1\ufe0f</p>"},{"location":"Loops_and_Conditionals/","title":"Loops and Conditionals","text":"<p>Loops and conditionals allow you to control the flow of logic in your program. They are essential when dealing with datasets, performing repetitive tasks, or applying filters in crop analysis.</p>"},{"location":"Loops_and_Conditionals/#conditional-statements-if-elif-else","title":"Conditional Statements (<code>if</code>, <code>elif</code>, <code>else</code>)","text":"<p>Use conditionals to execute different blocks of code based on logic.</p> <pre><code>yield_per_hectare = 2.5\n\nif yield_per_hectare &gt; 3:\n    print(\"High yield\")\nelif yield_per_hectare &gt; 2:\n    print(\"Moderate yield\")\nelse:\n    print(\"Low yield\")\n</code></pre> <p>Tips:</p> <ul> <li>Use <code>==</code> for equality, <code>!=</code> for inequality</li> <li>Use <code>and</code>, <code>or</code>, <code>not</code> for combining conditions</li> </ul>"},{"location":"Loops_and_Conditionals/#for-loops","title":"<code>for</code> Loops","text":"<p>Use a <code>for</code> loop to iterate over items in a list or a range of numbers.</p> <pre><code>crops = ['Maize', 'Beans', 'Sorghum']\n\nfor crop in crops:\n    print(\"Processing crop:\", crop)\n\n# Loop with range\nfor i in range(3):\n    print(\"Iteration:\", i)\n</code></pre>"},{"location":"Loops_and_Conditionals/#while-loops","title":"<code>while</code> Loops","text":"<p><code>while</code> loops run as long as a condition remains true.</p> <pre><code>counter = 0\n\nwhile counter &lt; 3:\n    print(\"Count:\", counter)\n    counter += 1\n</code></pre> <p>Be careful with infinite loops \u2014 always ensure your loop has an exit condition.</p>"},{"location":"Loops_and_Conditionals/#loop-control-break-and-continue","title":"Loop Control: <code>break</code> and <code>continue</code>","text":"<ul> <li><code>break</code>: exits the loop entirely</li> <li><code>continue</code>: skips to the next iteration</li> </ul> <pre><code>for crop in crops:\n    if crop == 'Beans':\n        continue  # Skip Beans\n    print(crop)\n\n# Breaking the loop\nfor crop in crops:\n    if crop == 'Sorghum':\n        break\n    print(crop)\n</code></pre>"},{"location":"Loops_and_Conditionals/#exercises","title":"Exercises","text":"<ol> <li>Write a condition to classify yield as <code>\"Low\"</code>, <code>\"Medium\"</code>, or <code>\"High\"</code>.</li> <li>Loop through a list of crops and print each in uppercase.</li> <li>Use a <code>while</code> loop to print numbers from 1 to 5.</li> <li>Break the loop when the crop <code>\"Sorghum\"</code> is found.</li> <li>Combine conditionals with a loop to only print crops with yield &gt; 2.0 tons/ha.</li> </ol> <p>\u2b05\ufe0f Previous: Numpy, Pandas | Next: Functions and File I/O \u27a1\ufe0f</p>"},{"location":"Masking_and_Clipping_Rasters/","title":"Masking and Clipping Rasters","text":"<p>Clipping a raster by a shapefile (Area of Interest - AOI) allows you to focus your analysis on a specific region, such as a farm or district.</p>"},{"location":"Masking_and_Clipping_Rasters/#required-libraries","title":"Required Libraries","text":"<pre><code>import rasterio\nimport geopandas as gpd\nfrom rasterio.mask import mask\nfrom rasterio.plot import show\n</code></pre>"},{"location":"Masking_and_Clipping_Rasters/#load-the-shapefile-aoi","title":"Load the Shapefile (AOI)","text":"<pre><code># Read AOI shapefile\naoi = gpd.read_file(\"rwanda_districts.shp\")\nprint(aoi.crs)\n</code></pre> <p>Make sure the CRS of the shapefile matches the raster.</p>"},{"location":"Masking_and_Clipping_Rasters/#clip-raster-by-aoi","title":"Clip Raster by AOI","text":"<pre><code>with rasterio.open(\"nyagatare_image.tif\") as src:\n    # Reproject AOI to match raster CRS\n    aoi = aoi.to_crs(src.crs)\n\n    # Mask raster using shapefile geometry\n    clipped_image, clipped_transform = mask(src, aoi.geometry, crop=True)\n    clipped_meta = src.meta.copy()\n\n# Update metadata\nclipped_meta.update({\n    \"height\": clipped_image.shape[1],\n    \"width\": clipped_image.shape[2],\n    \"transform\": clipped_transform\n})\n\n# Save clipped raster\nwith rasterio.open(\"nyagatare_clipped.tif\", \"w\", **clipped_meta) as dst:\n    dst.write(clipped_image)\n</code></pre>"},{"location":"Masking_and_Clipping_Rasters/#visualize-the-clipped-raster","title":"Visualize the Clipped Raster","text":"<pre><code>show(clipped_image[0], title=\"Clipped Raster\")\n</code></pre>"},{"location":"Masking_and_Clipping_Rasters/#why-clip-rasters","title":"Why Clip Rasters?","text":"<ul> <li>Reduce file size and processing time</li> <li>Focus analysis on relevant regions</li> <li>Prepare data for machine learning</li> </ul>"},{"location":"Masking_and_Clipping_Rasters/#exercises","title":"Exercises","text":"<ol> <li>Load a shapefile and print its CRS.</li> <li>Reproject the shapefile to match the raster CRS.</li> <li>Use <code>rasterio.mask.mask</code> to clip the raster.</li> <li>Save the clipped raster and view its metadata.</li> <li>Display the clipped raster using matplotlib or rasterio.</li> </ol>"},{"location":"Masking_and_Clipping_Rasters/#tips","title":"Tips","text":"<ul> <li>If your AOI has multiple polygons, consider simplifying it or clipping one feature at a time.</li> <li>You can use <code>.buffer(0)</code> on geometries to fix invalid shapes.</li> </ul> <p>\u2b05\ufe0f Previous: Opening and Exploring Raster Files | Next: Patch Extraction from Rasters \u27a1\ufe0f</p>"},{"location":"Opening_and_Exploring_Raster_Files/","title":"Opening and Exploring Raster Files","text":"<p>Raster data represents the world as a grid of cells (pixels), commonly used for satellite imagery, elevation models, and NDVI.</p> <p>Each pixel contains a value such as reflectance, temperature, or vegetation index.</p>"},{"location":"Opening_and_Exploring_Raster_Files/#opening-a-raster-file","title":"Opening a Raster File","text":"<p>Use the <code>rasterio</code> library to open and read raster files like <code>.tif</code>.</p> <pre><code>import rasterio\n\n# Open raster\nraster_path = \"nyagatare_image.tif\"\nwith rasterio.open(raster_path) as src:\n    print(\"Raster opened successfully!\")\n    print(src.profile)  # Metadata\n    print(\"CRS:\", src.crs)\n    print(\"Width, Height:\", src.width, src.height)\n    print(\"Number of Bands:\", src.count)\n</code></pre>"},{"location":"Opening_and_Exploring_Raster_Files/#reading-raster-bands","title":"Reading Raster Bands","text":"<p>You can read individual bands or all bands into NumPy arrays.</p> <pre><code>with rasterio.open(raster_path) as src:\n    band1 = src.read(1)  # Read the first band\n    print(\"Band shape:\", band1.shape)\n</code></pre> <p>Bands represent different wavelengths or indices (e.g., Red, NIR, NDVI).</p>"},{"location":"Opening_and_Exploring_Raster_Files/#visualizing-raster-data","title":"Visualizing Raster Data","text":"<p>Use <code>rasterio.plot.show()</code> or matplotlib to display raster images.</p> <pre><code>from rasterio.plot import show\nimport matplotlib.pyplot as plt\n\nwith rasterio.open(raster_path) as src:\n    show(src.read(1), title=\"Raster Band 1\")\n\n# Or manually plot with matplotlib\nplt.imshow(src.read(1), cmap='viridis')\nplt.title(\"Raster Band 1\")\nplt.colorbar()\nplt.show()\n</code></pre>"},{"location":"Opening_and_Exploring_Raster_Files/#raster-metadata-and-properties","title":"Raster Metadata and Properties","text":"<p>Each raster contains metadata describing its structure and location.</p> <pre><code>with rasterio.open(raster_path) as src:\n    print(\"Bounds:\", src.bounds)\n    print(\"Resolution:\", src.res)\n    print(\"Data Type:\", src.dtypes)\n</code></pre>"},{"location":"Opening_and_Exploring_Raster_Files/#exercises","title":"Exercises","text":"<ol> <li>Load a raster and print its metadata and number of bands.</li> <li>Read and display the first band using <code>rasterio</code>.</li> <li>Extract the pixel resolution and CRS.</li> <li>Calculate the min and max of a raster band.</li> <li>Try plotting the band with a different color map (<code>cmap</code>).</li> </ol>"},{"location":"Opening_and_Exploring_Raster_Files/#tip","title":"Tip","text":"<p>If you're using multi-band images (e.g., RGB or multispectral), explore combinations like:</p> <pre><code>r = src.read(3)\ng = src.read(2)\nb = src.read(1)\nrgb = np.stack([r, g, b], axis=-1)\nplt.imshow(rgb / 255)\n</code></pre> <p>\u2b05\ufe0f Previous: Reading and Plotting Shapefiles | Next: Masking and Clipping Rasters \u27a1\ufe0f</p>"},{"location":"Patch_Extraction_from_Rasters/","title":"Patch Extraction from Rasters","text":"<p>Patch extraction is a technique used in geospatial analysis and machine learning to break down large raster images into smaller, manageable chunks or patches.</p> <p>This is useful for:</p> <ul> <li>Training machine learning models</li> <li>Managing memory and computational load</li> <li>Spatial tiling for deep learning</li> </ul>"},{"location":"Patch_Extraction_from_Rasters/#required-libraries","title":"Required Libraries","text":"<pre><code>import rasterio\nimport numpy as np\nfrom rasterio.windows import Window\n</code></pre>"},{"location":"Patch_Extraction_from_Rasters/#set-patch-size-and-loop-through-image","title":"Set Patch Size and Loop Through Image","text":"<pre><code>patch_size = 64  # Size of each patch (64x64 pixels)\n\nwith rasterio.open(\"nyagatare_image.tif\") as src:\n    for i in range(0, src.height, patch_size):\n        for j in range(0, src.width, patch_size):\n            window = Window(j, i, patch_size, patch_size)\n            patch = src.read(window=window)\n            np.save(f\"patch_{i}_{j}.npy\", patch)\n</code></pre> <p>This will save each patch as a <code>.npy</code> file, which can later be loaded for training or analysis.</p>"},{"location":"Patch_Extraction_from_Rasters/#optional-filter-valid-patches","title":"Optional: Filter Valid Patches","text":"<p>You can skip patches that are full of NoData values or have too much cloud cover:</p> <pre><code>if np.all(patch == 0):\n    continue  # skip empty patch\n</code></pre>"},{"location":"Patch_Extraction_from_Rasters/#exercises","title":"Exercises","text":"<ol> <li>Extract 64\u00d764 patches from a raster and save them as <code>.npy</code> files.</li> <li>Try different patch sizes like 32, 128.</li> <li>Count how many patches were extracted.</li> <li>Create a mask to skip patches with low information content.</li> <li>Visualize one patch using <code>matplotlib</code>.</li> </ol> <pre><code>import matplotlib.pyplot as plt\nplt.imshow(patch[0], cmap='gray')\nplt.title(\"Sample Patch - Band 1\")\nplt.show()\n</code></pre>"},{"location":"Patch_Extraction_from_Rasters/#tip","title":"Tip","text":"<p>If you need overlapping patches (e.g., for segmentation), reduce the stride:</p> <pre><code>stride = 32  # overlap\n</code></pre> <p>This increases the number of patches and improves spatial learning in ML.</p> <p>\u2b05\ufe0f Previous: Masking and Clipping Rasters  | Next: Google Earth Engine Python API \u27a1\ufe0f</p>"},{"location":"Python_Environment_Management/","title":"Python Environment Management","text":"<p>Managing Python environments is essential for avoiding package conflicts and keeping your projects isolated. Below are common tools and methods for environment management.</p>"},{"location":"Python_Environment_Management/#required-python-packages","title":"Required Python Packages","text":"<p>To run all examples in this Training, install the following:</p>"},{"location":"Python_Environment_Management/#core-packages","title":"Core Packages","text":"Package Purpose <code>numpy</code> Numerical operations <code>pandas</code> Data manipulation <code>matplotlib</code> Plotting and visualization <code>scikit-learn</code> Machine learning (Random Forest, etc.) <code>tensorflow</code> Deep learning (CNN, model training)"},{"location":"Python_Environment_Management/#geospatial-libraries","title":"Geospatial Libraries","text":"Package Purpose <code>rasterio</code> Reading/writing raster data <code>geopandas</code> Handling shapefiles (vector data) <code>fiona</code> Shapefile I/O (used by geopandas) <code>pyproj</code> Coordinate reference system support <code>shapely</code> Geometry manipulation <code>earthengine-api</code> Google Earth Engine Python API"},{"location":"Python_Environment_Management/#extras","title":"Extras","text":"Package Purpose <code>jupyterlab</code> Interactive notebooks (optional) <code>ipykernel</code> Jupyter support for virtual envs <code>h5py</code> Reading <code>.h5</code> format (deep learning) <code>tqdm</code> Progress bars"},{"location":"Python_Environment_Management/#environment-setup-methods","title":"Environment Setup Methods","text":""},{"location":"Python_Environment_Management/#a-using-venv-built-in-python-virtual-environment","title":"A. Using <code>venv</code> (Built-in Python Virtual Environment)","text":"<pre><code>python -m venv geopy\nsource geopy/bin/activate        # Linux/macOS\n.\\geopy\\Scripts\u0007ctivate         # Windows\npip install numpy pandas geopandas rasterio scikit-learn tensorflow matplotlib\n</code></pre>"},{"location":"Python_Environment_Management/#b-using-conda-with-miniforge","title":"B. Using <code>conda</code> (With Miniforge)","text":"<pre><code>conda create -n geopy python=3.10\nconda activate geopy\nconda install numpy pandas matplotlib scikit-learn tensorflow rasterio geopandas fiona shapely pyproj earthengine-api\n\n</code></pre>"},{"location":"Python_Environment_Management/#c-installing-miniforge","title":"C. Installing Miniforge","text":"<p>Miniforge is a lightweight Conda alternative using conda-forge:</p> <pre><code># Download and install\nwget https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Linux-x86_64.sh\nbash Miniforge3-Linux-x86_64.sh\n</code></pre>"},{"location":"Python_Environment_Management/#using-environmentyml","title":"Using <code>environment.yml</code>","text":""},{"location":"Python_Environment_Management/#step-1-create-the-environmentyml-file","title":"Step 1: Create the <code>environment.yml</code> file","text":"<pre><code>name: geopy\nchannels:\n  - conda-forge\ndependencies:\n  - python=3.10\n  - numpy\n  - pandas\n  - matplotlib\n  - scikit-learn\n  - tensorflow\n  - rasterio\n  - geopandas\n  - fiona\n  - shapely\n  - pyproj\n  - earthengine-api\n</code></pre>"},{"location":"Python_Environment_Management/#step-2-create-the-environment-from-file","title":"Step 2: Create the environment from file","text":"<pre><code>conda env create -f environment.yml\n</code></pre>"},{"location":"Python_Environment_Management/#step-3-activate-the-environment","title":"Step 3: Activate the environment","text":"<pre><code>conda activate geopy\n</code></pre>"},{"location":"Python_Environment_Management/#step-4-export-your-environment-for-sharing","title":"Step 4: Export your environment (for sharing)","text":"<pre><code>conda env export &gt; environment.yml\n</code></pre>"},{"location":"Python_Environment_Management/#optional-using-pip-tools","title":"Optional: Using <code>pip-tools</code>","text":"<pre><code>pip install pip-tools\n\n# Create a minimal requirements file\necho \"rasterio\ntensorflow\nscikit-learn\" &gt; requirements.in\npip-compile requirements.in\npip install -r requirements.txt\n</code></pre>"},{"location":"Python_Environment_Management/#tips","title":"Tips","text":"<ul> <li>Use a fresh environment for each new project.</li> <li>Prefer <code>conda</code> for geospatial libraries (easier installation).</li> <li>Save <code>environment.yml</code> in your repo for reproducibility.</li> </ul> <p>\u2b05\ufe0f Home | Next: Introduction to Python Syntax \u27a1\ufe0f</p>"},{"location":"Reading_and_Plotting_Shapefiles/","title":"Reading and Plotting Shapefiles","text":"<p>Shapefiles are one of the most common formats for storing vector geospatial data. They typically contain points, lines, or polygons representing spatial features such as farms, roads, or regions.</p>"},{"location":"Reading_and_Plotting_Shapefiles/#components-of-a-shapefile","title":"Components of a Shapefile","text":"<p>A shapefile actually consists of multiple files with the same name but different extensions:</p> Extension Description <code>.shp</code> Geometry (points, lines, polygons) <code>.shx</code> Shape index <code>.dbf</code> Attribute table (metadata) <code>.prj</code> Coordinate reference system <p>You must keep these files together when loading a shapefile.</p>"},{"location":"Reading_and_Plotting_Shapefiles/#reading-a-shapefile-with-geopandas","title":"Reading a Shapefile with GeoPandas","text":"<pre><code>import geopandas as gpd\n\n# Load shapefile\ngdf = gpd.read_file(\"Nyagatare_A2021.shp\")\n\n# View first 5 rows\nprint(gdf.head())\n\n# View column names\nprint(gdf.columns)\n</code></pre>"},{"location":"Reading_and_Plotting_Shapefiles/#plotting-the-shapefile","title":"Plotting the Shapefile","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Simple plot\ngdf.plot()\nplt.title(\"Farm Boundaries in Nyagatare\")\nplt.show()\n\n# Plot by crop type\ngdf.plot(column=\"crop_type\", legend=True, cmap=\"Set3\")\nplt.title(\"Crop Types in Nyagatare\")\nplt.xlabel(\"Longitude\")\nplt.ylabel(\"Latitude\")\nplt.show()\n</code></pre> <p>You can customize plots with colors, legends, titles, and labels.</p>"},{"location":"Reading_and_Plotting_Shapefiles/#exploring-attribute-data","title":"Exploring Attribute Data","text":"<pre><code># Access specific columns\nprint(gdf[\"crop_type\"].value_counts())\n\n# Filter polygons by crop type\nmaize_farms = gdf[gdf[\"crop_type\"] == \"Maize\"]\nprint(maize_farms)\n</code></pre>"},{"location":"Reading_and_Plotting_Shapefiles/#exercises","title":"Exercises","text":"<ol> <li>Load a shapefile and print its first 5 records.</li> <li>Plot the shapefile with default style using <code>.plot()</code>.</li> <li>Create a color-coded plot based on the crop type or ownership.</li> <li>Count how many features belong to each crop type.</li> <li>Filter out polygons larger than a certain area and plot them separately.</li> </ol>"},{"location":"Reading_and_Plotting_Shapefiles/#reproject","title":"Reproject","text":"<p>Use <code>.to_crs()</code> to reproject your shapefile before plotting if it appears distorted or does not align with a base map.</p> <pre><code>gdf_utm = gdf.to_crs(epsg=32636)\ngdf_utm.plot()\n</code></pre> <p>\u2b05\ufe0f Previous: Coordinate Reference Systems (CRS) | Next: Opening and Exploring Raster Files \u27a1\ufe0f</p>"},{"location":"Syntax/","title":"Introduction to Python Syntax","text":"<p>Python syntax refers to the set of rules that defines how Python programs are written and interpreted. It is known for being clear and human-readable. Python uses indentation instead of braces to define code blocks.</p> <pre><code># This is a comment\nprint(\"Hello, world!\")  # Prints a message\n\nif True:\n    print(\"This is indented correctly\")\n\n# Incorrect indentation\nif True:\nprint(\"This will raise an IndentationError\")\n</code></pre> <pre><code># Simple Control Flow Example\nweather = \"rainy\"\n\nif weather == \"rainy\":\n    print(\"Crop might be overwatered.\")\nelse:\n    print(\"Irrigation might be needed.\")\n</code></pre> <p>Running Python Code:</p> <ul> <li>Save the script as <code>.py</code> and run from terminal: <code>python my_script.py</code></li> <li>Or use Jupyter Notebook / VS Code</li> </ul> <p>Exercise: Create <code>hello_crop.py</code> that prints a welcome message and current year using the datetime module.</p> <pre><code>import datetime\nprint(\"Welcome to Crop Type Mapping with Python!\")\nprint(\"Year:\", datetime.datetime.now().year)\n</code></pre> <p>\u2b05\ufe0f Python Environment Management | Next: Variables and Data Types \u27a1\ufe0f</p>"},{"location":"Variables/","title":"Variables, Data Types, and Operations","text":"<p>In Python, variables are used to store data that your program can access and manipulate. Each variable has a name and holds a value, which can be of different data types such as:</p> <ul> <li>Integers (e.g., <code>5</code>)</li> <li>Floating-point numbers (e.g., <code>3.14</code>)</li> <li>Strings (e.g., <code>'Maize'</code>)</li> <li>Booleans (e.g., <code>True</code>, <code>False</code>)</li> <li>Collections (e.g., lists, dictionaries, tuples)</li> </ul> <p>These data types are crucial in crop mapping tasks, where you handle numeric values (yield, area), names of crops, and logic checks.</p>"},{"location":"Variables/#declaring-variables","title":"Declaring Variables","text":"<p>Variables are created by assigning a value using the <code>=</code> operator.</p> <pre><code># Assigning values to variables\ncrop = 'Maize'           # String\narea = 5                 # Integer\nyield_per_hectare = 2.8  # Float\nis_irrigated = True      # Boolean\n</code></pre>"},{"location":"Variables/#data-types-in-practice","title":"Data Types in Practice","text":"<p>Python supports several built-in data types. Here are the most common ones you'll encounter in geospatial or agricultural analysis:</p> Type Description Example <code>int</code> Integer numbers <code>5</code>, <code>-10</code>, <code>2024</code> <code>float</code> Decimal numbers <code>2.5</code>, <code>0.01</code> <code>str</code> Text or characters <code>'Maize'</code>, <code>'Plot A'</code> <code>bool</code> Logical true/false <code>True</code>, <code>False</code> <code>list</code> Ordered, changeable collection <code>['Maize', 'Beans']</code> <code>dict</code> Key-value pairs <code>{'Maize': 2.5}</code>"},{"location":"Variables/#basic-operations","title":"Basic Operations","text":"<p>You can perform arithmetic or logical operations with variables.</p> <pre><code># Arithmetic\ntotal_yield = area * yield_per_hectare\nprint(\"Total Yield (tons):\", total_yield)\n\n# String concatenation\ncrop_info = \"Crop: \" + crop\nprint(crop_info)\n\n# Boolean logic\nif is_irrigated:\n    print(\"Field is irrigated\")\nelse:\n    print(\"Field is rainfed\")\n</code></pre>"},{"location":"Variables/#type-conversion","title":"Type Conversion","text":"<p>Sometimes, you need to convert values from one type to another using functions like <code>int()</code>, <code>float()</code>, <code>str()</code>, or <code>bool()</code>.</p> <pre><code>value = \"25\"\nvalue_int = int(value)  # Convert string to integer\nprint(value_int + 5)\n</code></pre>"},{"location":"Variables/#exercises","title":"Exercises","text":"<p>Try these on your own or in a Jupyter Notebook:</p> <ol> <li>Declare variables for a crop name, area of land (in hectares), and yield per hectare.</li> <li>Compute and print the total expected yield.</li> <li>Convert a number given as a string (e.g., <code>'10'</code>) into an integer and multiply it by 2.</li> <li>Write a condition that prints \"High Yield\" if yield &gt; 3, \"Moderate\" if between 2 and 3, else \"Low\".</li> </ol> <p>\u2b05\ufe0f Previous: Introduction to Python Syntax | Next: Lists, Dictionaries, and Tuples \u27a1\ufe0f</p>"},{"location":"Vector_vs_Raster_Data/","title":"Vector vs Raster Data","text":"<p>In geospatial applications, data is primarily represented in two formats: vector and raster. Each format has its strengths depending on the type of spatial feature or analysis you're performing.</p>"},{"location":"Vector_vs_Raster_Data/#vector-data","title":"Vector Data","text":"<p>Vector data represents real-world features using geometric shapes:</p> <ul> <li>Points: Individual locations (e.g., trees, wells)</li> <li>Lines: Linear features (e.g., rivers, roads)</li> <li>Polygons: Areas (e.g., farm plots, districts)</li> </ul> <p>Each feature can have attributes (e.g., crop type, owner).</p> <pre><code>import geopandas as gpd\n\n# Load a shapefile\ngdf = gpd.read_file('farms.shp')\n\n# Inspect the data\nprint(gdf.head())\nprint(gdf.geometry[0])\n</code></pre> <p>Vector data is ideal for:</p> <ul> <li>Boundary definitions</li> <li>Spatial joins and queries</li> <li>Attribute-rich analysis</li> </ul>"},{"location":"Vector_vs_Raster_Data/#raster-data","title":"Raster Data","text":"<p>Raster data is a grid of pixels where each pixel holds a value (e.g., reflectance, temperature, elevation).</p> <pre><code>import rasterio\nfrom rasterio.plot import show\n\n# Load a raster image\nwith rasterio.open('satellite_image.tif') as src:\n    print(\"Bands:\", src.count)\n    print(\"Size:\", src.width, \"x\", src.height)\n    show(src.read(1))  # Show first band\n</code></pre> <p>Raster data is ideal for:</p> <ul> <li>Satellite imagery</li> <li>Continuous surfaces (NDVI, elevation)</li> <li>Image classification and time series</li> </ul>"},{"location":"Vector_vs_Raster_Data/#key-differences","title":"Key Differences","text":"Feature Vector Raster Structure Points, lines, polygons Grid of pixels Best For Boundaries, discrete objects Surfaces, continuous data Storage Geometries + attributes Numeric pixel values File formats <code>.shp</code>, <code>.geojson</code>, <code>.gpkg</code> <code>.tif</code>, <code>.img</code>, <code>.nc</code>, <code>.hdf</code> Resolution Based on digitization accuracy Based on pixel size"},{"location":"Vector_vs_Raster_Data/#choosing-the-right-format","title":"Choosing the Right Format","text":"Task Recommended Format Mapping farm boundaries Vector Analyzing vegetation (NDVI) Raster Combining spatial attributes Vector Image classification Raster"},{"location":"Vector_vs_Raster_Data/#exercises","title":"Exercises","text":"<ol> <li>Open a shapefile using GeoPandas and print the geometry type.</li> <li>Open a raster using Rasterio and print metadata like CRS and size.</li> <li>Plot a vector and raster layer together using <code>matplotlib</code>.</li> <li>Describe three real-world use cases where each format is better suited.</li> <li>Bonus: Convert NDVI raster to vector by thresholding and vectorizing high NDVI areas.</li> </ol> <p>\u2b05\ufe0f Previous: Functions and File I/O | Next: Coordinate Reference Systems (CRS) \u27a1\ufe0f</p>"},{"location":"numpy_pandas_cheatsheet/","title":"NumPy and Pandas","text":""},{"location":"numpy_pandas_cheatsheet/#numpy-numerical-python","title":"NumPy (Numerical Python)","text":"<p>NumPy is the fundamental package for numerical computing in Python. It provides support for large, multi-dimensional arrays and matrices, along with a collection of mathematical functions to operate on these arrays.</p>"},{"location":"numpy_pandas_cheatsheet/#importing-numpy","title":"Importing NumPy","text":"<pre><code>import numpy as np\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#creating-arrays","title":"Creating Arrays","text":"<pre><code># 1D array\narr1 = np.array([1, 2, 3])\nprint(\"np.array([1, 2, 3]) \u2192\", arr1)\n\n# 2D array of zeros\narr2 = np.zeros((2, 3))\nprint(\"np.zeros((2, 3)) \u2192\\n\", arr2)\n\n# 1D array of ones\narr3 = np.ones(5)\nprint(\"np.ones(5) \u2192\", arr3)\n\n# Identity matrix\narr4 = np.eye(3)\nprint(\"np.eye(3) \u2192\\n\", arr4)\n\n# Range of values with step\narr5 = np.arange(0, 10, 2)\nprint(\"np.arange(0, 10, 2) \u2192\", arr5)\n\n# Evenly spaced values over interval\narr6 = np.linspace(0, 1, 5)\nprint(\"np.linspace(0, 1, 5) \u2192\", arr6)\n\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#array-operations","title":"Array Operations","text":"<pre><code>a = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\n\nprint(\"a + b \u2192\", a + b)\nprint(\"a - b \u2192\", a - b)\nprint(\"a * b \u2192\", a * b)\nprint(\"a / b \u2192\", a / b)\n\nprint(\"np.dot(a, b) \u2192\", np.dot(a, b))  # 1\u00d74 + 2\u00d75 + 3\u00d76 = 32\n\nprint(\"np.sum(a) \u2192\", np.sum(a))\nprint(\"np.mean(a) \u2192\", np.mean(a))\nprint(\"np.std(a) \u2192\", np.std(a))\nprint(\"np.max(a) \u2192\", np.max(a))\nprint(\"np.min(a) \u2192\", np.min(a))\nprint(\"np.argmin(a) \u2192\", np.argmin(a))  # index of min\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#indexing-and-slicing","title":"Indexing and Slicing","text":"<pre><code># Create a 3x3 2D array\na2d = np.array([[10, 20, 30],\n                [40, 50, 60],\n                [70, 80, 90]])\n\n# Access the first row\nprint(\"a2d[0] \u2192\", a2d[0])  # [10, 20, 30]\n\n# Slice rows from index 1 to 2 (1:3 means rows 1 and 2)\nprint(\"a2d[1:3] \u2192\\n\", a2d[1:3])  # [[40, 50, 60], [70, 80, 90]]\n\n# Access the last row using negative index\nprint(\"a2d[-1] \u2192\", a2d[-1])  # [70, 80, 90]\n\n# Access the second column from all rows\nprint(\"a2d[:, 1] \u2192\", a2d[:, 1])  # [20, 50, 80]\n\n# Access all columns of the second row\nprint(\"a2d[1, :] \u2192\", a2d[1, :])  # [40, 50, 60]\n\n# Slice a 2x2 subarray from rows 1-2 and columns 1-2\nprint(\"a2d[1:3, 1:3] \u2192\\n\", a2d[1:3, 1:3])  # [[50, 60], [80, 90]]\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#random-numbers","title":"Random Numbers","text":"<p>NumPy provides utilities to generate random numbers, which are very useful in simulations, testing, and initializing machine learning models.</p>"},{"location":"numpy_pandas_cheatsheet/#nprandomrand-uniform-distribution-in-0-1","title":"<code>np.random.rand()</code> \u2013 Uniform distribution in [0, 1)","text":"<p>Generates random float numbers between 0 and 1.</p> <pre><code>rand_array = np.random.rand(3, 2)\nprint(\"np.random.rand(3, 2) \u2192\\n\", rand_array)\n</code></pre> <p>Output: 3x2 matrix with random float values.</p>"},{"location":"numpy_pandas_cheatsheet/#nprandomrandint-random-integers-in-a-specified-range","title":"<code>np.random.randint()</code> \u2013 Random integers in a specified range","text":"<p>Generates random integers from the given range.</p> <pre><code>rand_int = np.random.randint(0, 10, size=(3, 3))\nprint(\"np.random.randint(0, 10, (3, 3)) \u2192\\n\", rand_int)\n</code></pre> <p>Output: 3x3 matrix with random integers from 0 to 9.</p>"},{"location":"numpy_pandas_cheatsheet/#nprandomseed-reproducibility","title":"<code>np.random.seed()</code> \u2013 Reproducibility","text":"<p>Sets a seed so that random numbers are the same across runs.</p> <pre><code>np.random.seed(42)\nprint(\"Seed set to 42 (for reproducibility)\")\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#useful-functions","title":"Useful Functions","text":"<pre><code>import numpy as np\n# Create an array with duplicates, NaN, and Inf values\narr = np.array([4, 2, 2, np.nan, np.inf, 4])\nprint(\"Original array \u2192\", arr)\n\n# Get unique elements from the array\nprint(\"np.unique(arr) \u2192\", np.unique(arr))\n\n# Sort the array (NaN values usually appear last)\nprint(\"np.sort(arr) \u2192\", np.sort(arr))\n\n# Concatenate two arrays\nconcat = np.concatenate(([1, 2], [3, 4]))\nprint(\"np.concatenate \u2192\", concat)\n\n# Reshape a 2x3 array into 3x2\nreshaped = np.array([[1, 2, 3], [4, 5, 6]]).reshape((3, 2))\nprint(\"np.reshape \u2192\\n\", reshaped)\n\n# Flatten the reshaped array into a 1D array\nflat = reshaped.flatten()\nprint(\"np.flatten \u2192\", flat)\n\n# Add an extra dimension (row vector)\nexp_dim = np.expand_dims(np.array([1, 2]), axis=0)\nprint(\"np.expand_dims \u2192\", exp_dim)\n\n# Check for NaN values\nprint(\"np.isnan(arr) \u2192\", np.isnan(arr))\n\n# Check for infinite values\nprint(\"np.isinf(arr) \u2192\", np.isinf(arr))\n\n# Find indices where value is 4\nprint(\"np.where(arr == 4) \u2192\", np.where(arr == 4))\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#pandas-python-data-analysis-library","title":"Pandas (Python Data Analysis Library)","text":"<p>Pandas is the go\u2011to library for working with tabular data (rows &amp; columns). It builds on NumPy and adds labeled axes, powerful indexing, grouping, joining, time\u2011series tools, and I/O.</p>"},{"location":"numpy_pandas_cheatsheet/#importing-pandas","title":"Importing Pandas","text":"<pre><code>import pandas as pd\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#creating-data-structures","title":"Creating Data Structures","text":""},{"location":"numpy_pandas_cheatsheet/#series-1d-labeled","title":"Series (1D, labeled)","text":"<pre><code>s = pd.Series([1, 2, 3], name=\"values\")\nprint(s)\nprint(\"Index:\", s.index)\nprint(\"Values:\", s.values)\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#dataframe-2d-table","title":"DataFrame (2D table)","text":"<pre><code>df = pd.DataFrame({'a': [1, 2], 'b': [3, 4]})\nprint(df)\nprint(\"Columns:\", df.columns)\nprint(\"Shape:\", df.shape)\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#inputoutput","title":"Input/Output","text":""},{"location":"numpy_pandas_cheatsheet/#read","title":"Read","text":"<pre><code>df = pd.read_csv('file.csv')\ndf = pd.read_excel('file.xlsx')\ndf = pd.read_json('file.json')\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#write","title":"Write","text":"<pre><code>df.to_csv('out.csv', index=False)\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#inspecting-data","title":"Inspecting Data","text":"<pre><code>df.head()\ndf.tail()\ndf.info()\ndf.describe()\ndf.shape\ndf.columns\ndf.dtypes\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#selecting-data","title":"Selecting Data","text":""},{"location":"numpy_pandas_cheatsheet/#column-selection","title":"Column selection","text":"<pre><code>df['col']\ndf[['col1','col2']]\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#row-selection","title":"Row selection","text":"<pre><code>df.loc[0]\ndf.iloc[0]\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#boolean-filtering","title":"Boolean filtering","text":"<pre><code>df[df['col'] &gt; 10]\ndf.query(\"col &gt; 10\")\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#cleaning-data","title":"Cleaning Data","text":"<pre><code>df.dropna()\ndf.fillna(0)\ndf.replace('NA', pd.NA)\ndf.drop(columns=['col1'])\ndf.rename(columns={'a':'A'})\ndf['col'] = df['col'].astype(int)\ndf.duplicated()\ndf.drop_duplicates()\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#aggregation-grouping","title":"Aggregation &amp; Grouping","text":"<pre><code>df.groupby('group_col')['value'].mean()\ndf.groupby('group_col').agg({'value':'mean', 'other':'sum'})\npd.pivot_table(df, values='val', index='group', columns='type')\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#merging-joining","title":"Merging &amp; Joining","text":"<pre><code>pd.concat([df1, df2])\npd.merge(df1, df2, on='key')\ndf1.join(df2.set_index('key'), on='key')\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#sorting","title":"Sorting","text":"<pre><code>df.sort_values('col', ascending=False)\ndf.sort_index()\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#time-series","title":"Time Series","text":"<pre><code>df['date'] = pd.to_datetime(df['date'])\ndf.set_index('date').resample('M').mean()\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#math-stats","title":"Math &amp; Stats","text":"<pre><code>df['col'].mean()\ndf['col'].std()\ndf.corr()\ndf['col'].cumsum()\n</code></pre>"},{"location":"numpy_pandas_cheatsheet/#apply-map","title":"Apply &amp; Map","text":"<pre><code>df['col'].apply(lambda x: x * 2)\ndf['label'].map({'A':1, 'B':2})\ndf.applymap(lambda x: len(str(x)))\n</code></pre> <p>\u2b05\ufe0f Previous: Lists, Dictionaries, and Tuples | Next: Loops and Conditionals \u27a1\ufe0f</p>"}]}